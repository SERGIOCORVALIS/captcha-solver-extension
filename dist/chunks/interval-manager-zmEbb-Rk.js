const e=new class{enabled=!1;logs=[];maxLogs=100;setEnabled(e){this.enabled=e}isEnabled(){return this.enabled}log(e,t,s){if(!this.enabled&&"DEBUG"===e)return;const i={level:e,message:t,timestamp:Date.now(),context:s};this.logs.push(i),this.logs.length>this.maxLogs&&this.logs.shift();const a=`[CAPTCHA Solver] [${e}]`,n=s?` ${JSON.stringify(s)}`:"";switch(e){case"DEBUG":console.debug(a,t,n);break;case"INFO":console.info(a,t,n);break;case"WARN":console.warn(a,t,n);break;case"ERROR":console.error(a,t,n)}}debug(e,t){this.log("DEBUG",e,t)}info(e,t){this.log("INFO",e,t)}warn(e,t){this.log("WARN",e,t)}error(e,t){this.log("ERROR",e,t)}getLogs(){return[...this.logs]}clearLogs(){this.logs=[]}exportLogs(){return JSON.stringify(this.logs,null,2)}};var t=(e=>(e.DETECT_CAPTCHA="DETECT_CAPTCHA",e.SOLVE_CAPTCHA="SOLVE_CAPTCHA",e.CAPTCHA_DETECTED="CAPTCHA_DETECTED",e.CAPTCHA_SOLVED="CAPTCHA_SOLVED",e.CAPTCHA_ERROR="CAPTCHA_ERROR",e.INJECT_TOKEN="INJECT_TOKEN",e.GET_CONFIG="GET_CONFIG",e.UPDATE_CONFIG="UPDATE_CONFIG",e.GET_STATISTICS="GET_STATISTICS",e.RESET_STATISTICS="RESET_STATISTICS",e.TOGGLE_ENABLED="TOGGLE_ENABLED",e.GET_STATUS="GET_STATUS",e))(t||{});async function s(e,t={}){const{maxAttempts:s=3,delay:i=1e3,backoff:a="exponential",onRetry:n}=t;let r=null;for(let l=1;l<=s;l++)try{return await e()}catch(o){if(r=o instanceof Error?o:new Error("Unknown error"),l===s)throw r;n&&n(l,r);const e="exponential"===a?i*Math.pow(2,l-1):i*l;await new Promise(t=>setTimeout(t,e))}throw r||new Error("Retry failed")}const i=new class{cache=new Map;TTL=3e4;MAX_SIZE=50;getKey(e,t){return`${e}:${t||"none"}`}get(e,t){const s=this.getKey(e,t),i=this.cache.get(s);return i?Date.now()>i.expiresAt?(this.cache.delete(s),null):(i.lastAccessed=Date.now(),this.cache.set(s,i),[i.detection]):null}set(e,t,s){if(0===t.length)return;const i=t[0],a=this.getKey(e,i.siteKey||s);if(this.cache.size>=this.MAX_SIZE&&!this.cache.has(a)){let e=null,t=1/0;for(const[s,i]of this.cache.entries())i.lastAccessed<t&&(t=i.lastAccessed,e=s);e&&this.cache.delete(e)}const n=Date.now();this.cache.set(a,{detection:i,timestamp:n,expiresAt:n+this.TTL,lastAccessed:n})}clear(){this.cache.clear()}cleanExpired(){const e=Date.now();for(const[t,s]of this.cache.entries())e>s.expiresAt&&this.cache.delete(t)}getStats(){return{size:this.cache.size,maxSize:this.MAX_SIZE,ttl:this.TTL}}},a=new class{intervals=new Map;timeouts=new Map;setInterval(e,t,s){this.clearInterval(e),this.intervals.set(e,setInterval(t,s))}setTimeout(e,t,s){this.clearTimeout(e),this.timeouts.set(e,setTimeout(()=>{t(),this.timeouts.delete(e)},s))}clearInterval(e){const t=this.intervals.get(e);t&&(clearInterval(t),this.intervals.delete(e))}clearTimeout(e){const t=this.timeouts.get(e);t&&(clearTimeout(t),this.timeouts.delete(e))}clearAll(){this.intervals.forEach(e=>clearInterval(e)),this.intervals.clear(),this.timeouts.forEach(e=>clearTimeout(e)),this.timeouts.clear()}getIntervalCount(){return this.intervals.size}getTimeoutCount(){return this.timeouts.size}};export{t as M,i as d,a as i,e as l,s as r};
